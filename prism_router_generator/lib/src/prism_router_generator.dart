import 'dart:async';

import 'package:analyzer/dart/element/element.dart';
import 'package:analyzer/dart/element/nullability_suffix.dart';
import 'package:analyzer/dart/element/type.dart';
import 'package:build/build.dart';
import 'package:glob/glob.dart';
import 'package:prism_router_annotations/prism_router_annotations.dart';
import 'package:source_gen/source_gen.dart';

final _routeChecker = TypeChecker.fromRuntime(PrismRoute);

final class PrismRouterGenerator
    extends GeneratorForAnnotation<PrismRouterConfig> {
  @override
  FutureOr<String> generateForAnnotatedElement(
    Element element,
    ConstantReader annotation,
    BuildStep buildStep,
  ) async {
    // Only generate once per library via the config entrypoint.
    final lib = element.library;
    if (lib == null) return '';

    final routes = await _collectRoutes(buildStep);
    if (routes.isEmpty) {
      return '${_headerComment('No @PrismRoute found.')}\n';
    }

    // Stable order: by segment, then by screen name (to keep diffs predictable).
    routes.sort((a, b) {
      final c = a.segment.compareTo(b.segment);
      if (c != 0) return c;
      return a.screen.displayName.compareTo(b.screen.displayName);
    });

    final initial = _pickInitial(routes);

    final out = StringBuffer();
    out.writeln(
      _headerComment('Generated by prism_router_generator. Do not edit.'),
    );

    // Page wrappers.
    for (final r in routes) {
      out.writeln(_generatePageClass(r));
      out.writeln();
    }

    // appRoutes + initialStack.
    out.writeln(
      'final List<PrismRouteDefinition> appRoutes = <PrismRouteDefinition>[',
    );
    for (final r in routes) {
      out.writeln(
        '  PrismRouteDefinition(name: ${_q(r.segment)}, builder: ${r.pageClassName}.fromArgs),',
      );
    }
    out.writeln('];');
    out.writeln();

    out.writeln('final List<PrismPage> initialStack = <PrismPage>[');
    out.writeln('  ${initial.pageClassName}(),');
    out.writeln('];');
    out.writeln();

    // buildPrismRouterConfig
    out.writeln('RouterConfig<Object> buildPrismRouterConfig({');
    out.writeln(
      '  PrismWebHistoryMode webHistoryMode = PrismWebHistoryMode.entries,',
    );
    out.writeln(
      '  List<NavigatorObserver> observers = const <NavigatorObserver>[],',
    );
    out.writeln(
      '  TransitionDelegate<Object> transitionDelegate = const DefaultTransitionDelegate<Object>(),',
    );
    out.writeln('  String? restorationScopeId,');
    out.writeln('  PrismGuard guards = const <PrismNavigationGuard>[],');
    out.writeln('}) {');
    out.writeln('  return PrismRouter.router(');
    out.writeln('    initialStack: initialStack,');
    out.writeln('    routes: appRoutes,');
    out.writeln('    webHistoryMode: webHistoryMode,');
    out.writeln('    observers: observers,');
    out.writeln('    transitionDelegate: transitionDelegate,');
    out.writeln('    restorationScopeId: restorationScopeId,');
    out.writeln('    guards: guards,');
    out.writeln('  );');
    out.writeln('}');

    return '${out.toString().trimRight()}\n';
  }

  Future<List<_RouteInfo>> _collectRoutes(BuildStep buildStep) async {
    final package = buildStep.inputId.package;
    final routes = <_RouteInfo>[];

    // NOTE: `buildStep.resolver.libraries` can be incomplete in incremental
    // builds because the resolver may only expose libraries that were already
    // loaded/needed for the current input. To reliably discover all annotated
    // screens, we explicitly scan the package's `lib/` sources and resolve them.
    await for (final id in buildStep.findAssets(Glob('lib/**.dart'))) {
      if (id.package != package) continue;

      // Skip generated source files; they can be `part of ...` and aren't valid
      // library entrypoints for route discovery.
      final p = id.path;
      if (p.endsWith('.g.dart')) continue;

      LibraryElement lib;
      try {
        lib = await buildStep.resolver.libraryFor(id);
      } catch (_) {
        // Not a library (e.g. a `part of ...` file) or failed to resolve.
        continue;
      }

      final reader = LibraryReader(lib);
      for (final annotated in reader.annotatedWith(_routeChecker)) {
        final el = annotated.element;
        if (el is! ClassElement) continue;

        final ann = annotated.annotation;
        final segment = _segmentFor(el, ann);
        final pageName = _pageClassNameFor(el.displayName);
        final initial = ann.peek('initial')?.boolValue ?? false;
        final tags = _readStringSet(ann.peek('tags'));
        final transition = _readTransition(ann.peek('transition'));

        routes.add(
          _RouteInfo(
            screen: el,
            segment: segment,
            pageClassName: pageName,
            initial: initial,
            tags: tags,
            transition: transition,
          ),
        );
      }
    }

    return routes;
  }

  _RouteInfo _pickInitial(List<_RouteInfo> routes) {
    for (final r in routes) {
      if (r.initial) return r;
    }
    return routes.first;
  }

  String _generatePageClass(_RouteInfo r) {
    final ctor = _pickConstructor(r.screen);
    final params = ctor == null ? <ParameterElement>[] : ctor.parameters;

    // Exclude widget keys; PrismPage already has its own key and screens commonly
    // accept a `Key? key` / `super.key` which is optional.
    final usableParams = params
        .where((p) => p.name != 'key')
        .toList(growable: false);

    if (usableParams.any((p) => !p.isNamed)) {
      throw InvalidGenerationSourceError(
        'prism_router_generator currently supports only named constructor '
        'parameters on @PrismRoute screens (positional parameters are not supported).',
        element: ctor ?? r.screen,
      );
    }

    final pageCtorParams = usableParams.map(_emitPageCtorParam).join(', ');
    final fieldDecls = usableParams.map(_emitFieldDecl).join('\n');
    final argsMap =
        usableParams.isEmpty
            ? 'const <String, Object?>{}'
            : '<String, Object?>{${usableParams.map((p) => '${_q(p.name)}: ${p.name}').join(', ')}}';

    final childArgs = usableParams
        .map((p) => '${p.name}: ${p.name}')
        .join(', ');
    final childExpr =
        childArgs.isEmpty
            ? '${r.screen.displayName}()'
            : '${r.screen.displayName}($childArgs)';

    final tagsExpr =
        r.tags.isEmpty
            ? 'null'
            : 'const <String>{${r.tags.map(_q).join(', ')}}';

    final fromArgsBody = _emitFromArgs(r, usableParams);

    final transitionOverride = _emitTransitionOverride(r.transition);

    return '''
final class ${r.pageClassName} extends PrismPage {
  ${r.pageClassName}({${pageCtorParams.isEmpty ? '' : '$pageCtorParams, '}LocalKey? pageKey})
      : super(
          name: ${_q(r.segment)},
          child: $childExpr,
          arguments: $argsMap,
          tags: $tagsExpr,
          key: pageKey,
        );

${fieldDecls.isEmpty ? '' : '  $fieldDecls\n'}
  static PrismPage fromArgs(Map<String, Object?> arguments) {
$fromArgsBody
  }

  @override
  PrismPage pageBuilder(Map<String, Object?> arguments) => fromArgs(arguments);
${transitionOverride.isEmpty ? '' : '\n$transitionOverride'}
}
''';
  }
}

/// Generates an import/export barrel for all `@PrismRoute` screens in the
/// current package.
///
/// Why: the router output is generated as a `.g.dart` **part**, and Dart parts
/// cannot declare their own `import` directives. This barrel lets users add a
/// **single** import (e.g. `import 'app_router.imports.g.dart';`) to make all
/// annotated screens visible to the router library.
final class PrismRouterImportsGenerator
    extends GeneratorForAnnotation<PrismRouterConfig> {
  @override
  FutureOr<String> generateForAnnotatedElement(
    Element element,
    ConstantReader annotation,
    BuildStep buildStep,
  ) async {
    final package = buildStep.inputId.package;
    final exportUris = <String>{};

    await for (final id in buildStep.findAssets(Glob('lib/**.dart'))) {
      if (id.package != package) continue;

      final p = id.path;
      // Skip generated sources.
      if (p.endsWith('.g.dart')) continue;

      LibraryElement lib;
      try {
        lib = await buildStep.resolver.libraryFor(id);
      } catch (_) {
        // Not a resolvable library (e.g. a `part of ...` file).
        continue;
      }

      final reader = LibraryReader(lib);
      if (reader.annotatedWith(_routeChecker).isEmpty) continue;

      final withoutLibPrefix = p.startsWith('lib/') ? p.substring(4) : p;
      exportUris.add('package:$package/$withoutLibPrefix');
    }

    final exports = exportUris.toList()..sort();

    final out = StringBuffer();
    out.writeln('// ignore_for_file: directives_ordering');
    out.writeln();
    out.writeln(
      '// Re-export all @PrismRoute screens so the router library can see them.',
    );

    if (exports.isEmpty) {
      out.writeln('// No @PrismRoute found.');
      return '${out.toString().trimRight()}\n';
    }

    for (final uri in exports) {
      out.writeln("export '${uri.replaceAll("'", "\\'")}';");
    }

    return '${out.toString().trimRight()}\n';
  }
}

final class _RouteInfo {
  const _RouteInfo({
    required this.screen,
    required this.segment,
    required this.pageClassName,
    required this.initial,
    required this.tags,
    required this.transition,
  });

  final ClassElement screen;
  final String segment;
  final String pageClassName;
  final bool initial;
  final Set<String> tags;
  final PrismTransition transition;
}

String _headerComment(String msg) => '// $msg';

String _q(String s) => "'${s.replaceAll("'", "\\'")}'";

final RegExp _screenNameSuffix = RegExp(r'^(.*)Screen(\d*)$');

ConstructorElement? _pickConstructor(ClassElement c) {
  // Prefer unnamed (default) constructor, otherwise any public constructor.
  final unnamed = c.constructors.where((k) => k.name.isEmpty).toList();
  if (unnamed.isNotEmpty) return unnamed.first;
  final publics = c.constructors.where((k) => !k.isPrivate).toList();
  if (publics.isNotEmpty) return publics.first;
  return null;
}

String _segmentFor(ClassElement screen, ConstantReader ann) {
  final raw = ann.peek('path')?.stringValue;
  if (raw != null && raw.trim().isNotEmpty) {
    var p = raw.trim();
    if (p.startsWith('/')) p = p.substring(1);
    if (p.endsWith('/')) p = p.substring(0, p.length - 1);
    // Only single segment is supported in Prism Router URL stacking.
    if (p.contains('/')) {
      throw InvalidGenerationSourceError(
        '@PrismRoute.path must be a single segment (e.g. "/home"), got: $raw',
        element: screen,
      );
    }
    return p;
  }

  // Default: HomeScreen -> home
  var name = screen.displayName;
  final m = _screenNameSuffix.firstMatch(name);
  if (m != null) {
    name = '${m.group(1) ?? ''}${m.group(2) ?? ''}';
  } else if (name.endsWith('Screen')) {
    name = name.substring(0, name.length - 'Screen'.length);
  }
  if (name.isEmpty) return 'route';
  return _pascalToKebab(name);
}

String _pageClassNameFor(String screenName) {
  final m = _screenNameSuffix.firstMatch(screenName);
  if (m != null) {
    final prefix = (m.group(1) ?? '').trim();
    final numericSuffix = (m.group(2) ?? '').trim();
    final base = prefix.isEmpty ? 'Route' : prefix;
    // SettingsScreen2 -> SettingsPage2 (instead of Settings2Page)
    return numericSuffix.isEmpty ? '${base}Page' : '${base}Page$numericSuffix';
  }

  var base = screenName;
  if (base.endsWith('Screen')) {
    base = base.substring(0, base.length - 'Screen'.length);
  }
  if (base.isEmpty) base = 'Route';
  return '${base}Page';
}

String _pascalToKebab(String input) {
  final sb = StringBuffer();
  for (var i = 0; i < input.length; i++) {
    final ch = input[i];
    final isUpper = ch.toUpperCase() == ch && ch.toLowerCase() != ch;
    if (i > 0 && isUpper) {
      final prev = input[i - 1];
      final prevIsUpper =
          prev.toUpperCase() == prev && prev.toLowerCase() != prev;
      if (!prevIsUpper) sb.write('-');
    }
    sb.write(ch.toLowerCase());
  }
  return sb.toString();
}

Set<String> _readStringSet(ConstantReader? reader) {
  if (reader == null || reader.isNull) return const <String>{};
  final set = <String>{};
  for (final v in reader.setValue) {
    final s = v.toStringValue();
    if (s != null) set.add(s);
  }
  return set;
}

PrismTransition _readTransition(ConstantReader? reader) {
  if (reader == null || reader.isNull) return PrismTransition.material;
  // Enum values are most reliably read via the underlying `index`.
  final index = reader.objectValue.getField('index')?.toIntValue();
  return switch (index) {
    1 => PrismTransition.zoom,
    2 => PrismTransition.fade,
    3 => PrismTransition.slide,
    _ => PrismTransition.material,
  };
}

String _emitPageCtorParam(ParameterElement p) {
  final defaultCode = p.defaultValueCode;

  // Only named parameters are supported by the generator.
  if (p.isRequiredNamed) {
    return 'required this.${p.name}';
  }
  if (defaultCode != null) {
    return 'this.${p.name} = $defaultCode';
  }
  return 'this.${p.name}';
}

String _emitFieldDecl(ParameterElement p) {
  final type = p.type.getDisplayString(withNullability: true);
  return 'final $type ${p.name};';
}

String _emitFromArgs(_RouteInfo r, List<ParameterElement> params) {
  if (params.isEmpty) {
    return '    return ${r.pageClassName}();';
  }

  // Pattern match required params when possible (String/int/bool/double/num).
  final patternEntries = <String>[];
  final ctorArgs = <String>[];
  for (final p in params) {
    final t = p.type;
    final typeStr = t.getDisplayString(withNullability: false);

    // Use type pattern only for simple core types; otherwise just parse later.
    if (_isSimpleTypePattern(t)) {
      patternEntries.add('${_q(p.name)}: $typeStr ${p.name}');
    }

    if (p.isNamed) {
      ctorArgs.add('${p.name}: ${_parseArgExpr(p)}');
    } else {
      ctorArgs.add(_parseArgExpr(p));
    }
  }

  final sb = StringBuffer();
  if (patternEntries.isNotEmpty) {
    sb.writeln('    if (arguments case {${patternEntries.join(', ')}}) {');
    // In the pattern match branch, variables are already typed, so just forward.
    final okArgs = params
        .map((p) => p.isNamed ? '${p.name}: ${p.name}' : p.name)
        .join(', ');
    sb.writeln('      return ${r.pageClassName}($okArgs);');
    sb.writeln('    }');
  }
  sb.writeln('    return ${r.pageClassName}(${ctorArgs.join(', ')});');
  return sb.toString().trimRight();
}

bool _isSimpleTypePattern(DartType t) {
  final elem = t.element;
  if (elem is! ClassElement) return false;
  final name = elem.name;
  return name == 'String' ||
      name == 'int' ||
      name == 'double' ||
      name == 'num' ||
      name == 'bool';
}

String _parseArgExpr(ParameterElement p) {
  final t = p.type;
  final typeStr = t.getDisplayString(withNullability: true);
  final baseTypeStr = t.getDisplayString(withNullability: false);
  final key = _q(p.name);

  // If parameter has an explicit default value, use it.
  final defaultCode = p.defaultValueCode;

  // Nullable or optional named: cast and return.
  if (t.nullabilitySuffix != NullabilitySuffix.none) {
    if (defaultCode != null) {
      return '(arguments[$key] as $baseTypeStr?) ?? ($defaultCode)';
    }
    return 'arguments[$key] as $typeStr';
  }

  // Non-nullable.
  if (defaultCode != null) {
    return '(arguments[$key] as $baseTypeStr?) ?? ($defaultCode)';
  }

  // Built-in safe fallbacks.
  final fallback = switch (baseTypeStr) {
    'String' => "''",
    'int' => '0',
    'double' => '0.0',
    'num' => '0',
    'bool' => 'false',
    _ => null,
  };
  if (fallback != null) {
    return '(arguments[$key] as $baseTypeStr?) ?? $fallback';
  }

  // For unsupported non-nullable types, fail fast (developer should make it
  // nullable or provide a default value).
  return 'arguments[$key] as $baseTypeStr';
}

String _emitTransitionOverride(PrismTransition transition) {
  switch (transition) {
    case PrismTransition.material:
      return '';
    case PrismTransition.zoom:
      return '''
  @override
  Route<void> createRoute(BuildContext context) {
    return PageRouteBuilder<void>(
      settings: this,
      pageBuilder: (context, animation, secondaryAnimation) => child,
      transitionsBuilder: (context, animation, secondaryAnimation, child) {
        final curved = CurvedAnimation(parent: animation, curve: Curves.easeOutCubic);
        return FadeTransition(
          opacity: curved,
          child: ScaleTransition(scale: curved, child: child),
        );
      },
    );
  }
''';
    case PrismTransition.fade:
      return '''
  @override
  Route<void> createRoute(BuildContext context) {
    return PageRouteBuilder<void>(
      settings: this,
      pageBuilder: (context, animation, secondaryAnimation) => child,
      transitionsBuilder: (context, animation, secondaryAnimation, child) {
        return FadeTransition(opacity: animation, child: child);
      },
    );
  }
''';
    case PrismTransition.slide:
      return '''
  @override
  Route<void> createRoute(BuildContext context) {
    return PageRouteBuilder<void>(
      settings: this,
      pageBuilder: (context, animation, secondaryAnimation) => child,
      transitionsBuilder: (context, animation, secondaryAnimation, child) {
        final tween = Tween<Offset>(
          begin: const Offset(1.0, 0.0),
          end: Offset.zero,
        ).chain(CurveTween(curve: Curves.easeOutCubic));
        return SlideTransition(position: animation.drive(tween), child: child);
      },
    );
  }
''';
  }
}
